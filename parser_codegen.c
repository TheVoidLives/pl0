#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "pl0.h"

// Note: The INPUT to the parser is the HEAD of the Lexeme 
// Table as generated by the Lexer.
int parse(int printFlag) 
{
   if (tableHead == NULL) 
   {
   }

   errHandle = program();

   if (errHandle != 0) 
   {
      return errHandle;
   }

   if (printFlag == 1) 
   {
      printIR();
   }

   return 0;
}

int program ()
{
   token = tableHead;
   errHandle = block();

   if (errHandle != 0) 
   {
      return errHandle;
   }

   if (token->ID != periodsym) 
   {
      // TODO: handle error
      return -1;
   }

   return 0;
}

int block()
{
   curInsertionOffset = 4;

   // If the token is a constant load all 
   // constants into the Symbol Table
   if (token->ID == constsym) 
   {
      toBeInserted.kind = 1;

      do 
      {
         token = token->next;

         if (token->ID != identsym)
         {
            // TODO: handle error
            return -1;
         }
         strcpy(toBeInserted.name, token->word);
         token = token->next;

         if (token->ID != eqsym)
         {
            //TODO: handle error
            return -1;
         }
         token = token->next;

         if (token->ID != numbersym)
         {
            //TODO: handle error
            return -1;
         }
         toBeInserted.value = atoi(token->word);
         toBeInserted.level = varLexical;
         toBeInserted.address = curInsertionOffset++;
         toBeInserted.mark = 0;
         addToTable(toBeInserted);

         token = token->next;

      } while (token->ID == commasym);

      if (token->ID != semicolonsym) 
      {
         // TODO: handle error
         return -1;
      }
      token = token->next;
   }

   // If the token is a var load all 
   // variables into the Symbol Table
   if (token->ID == varsym)
   {
      toBeInserted.kind = 2;
      do 
      {
         token = token->next;

         if (token->ID != identsym)
         {
            //TODO: hanlde error
            return -1;
         }
         strcpy(toBeInserted.name, token->word);
         toBeInserted.value = 0;
         toBeInserted.level = varLexical;
         toBeInserted.address = curInsertionOffset++;
         toBeInserted.mark = 0;

         token = token->next;

      } while (token->ID == commasym);

      if (token->ID != semicolonsym) 
      {
         // TODO: handle error
         return -1;
      }
      token = token->next;
   }

   // currInsertionOffset - Size of AR allocate in STACK
   gen(6, 0, 0, curInsertionOffset);
   errHandle = statement();

   if (errHandle != 0)
      return errHandle;

   return 0;
}


int statement() 
{
   // ifPC is local to the ifsym func.
   // w1PC and w2PC are local to the whilesym func.
   int ifPC, w1PC, w2PC;
   Symbol *currentSymbol = NULL;

   switch (token->ID) 
   {
      case identsym:
         currentSymbol = lookUp(token->word);
         token = token->next;

         if (currentSymbol == NULL) 
         {
            // TODO; Handle Error
            return -1;
         }

         if (token->ID != becomessym) 
         {
            // TODO; Handle Error
            return -1;
         }

         errHandle = expression();

         if (errHandle != 0) 
         {
            return errHandle;
         }

         searchLexical = abs(currLexical - currentSymbol->level);
         gen(4, currRegPos, searchLexical, currentSymbol->address);

         return 0;
      case beginsym:
         token = token->next;
         errHandle = statement();

         if (errHandle != 0) 
         {
            return errHandle;
         }

         while (token->ID == semicolonsym) 
         {
            token = token->next;
            errHandle = statement();

            if (errHandle != 0) 
            {
               return errHandle;
            }
         }

         if (token->ID != endsym)
         {
            // TODO: Handle Error
            return -1;
         }
         return 0;
      case ifsym:
         token = token->next;
         errHandle = condition();

         if (errHandle != 0) 
         {
            return errHandle;
         }

         if (token->ID != thensym) 
         {
            // TODO: Handle Error
            return -1;
         }

         token = token->next; 
         ifPC = currPC;

         gen(8, currRegPos, 0, 0);
         errHandle = statement();

         if (errHandle != 0) 
         {
            return errHandle;
         }

         IR[ifPC].M = currPC;

         return 0;
      case whilesym:
         // Save Current PC for later acces 
         w1PC = currPC;
         token = token->next;
         errHandle = condition();

         if (errHandle != 0) 
         {
            return errHandle;
         }

         w2PC = currPC;
         gen(8, currRegPos, 0, 0);
         if (token->ID != dosym) 
         {
            // TODO: Handle Error 
            return -1;
         }
         token = token->next;
         errHandle = statement();

         if (errHandle != 0) 
         {
            return errHandle;
         }

         gen(7, 0, 0, w1PC);
         IR[w2PC].M = currPC;
         return 0;
      default:
         return -1; // Death to your compiler
   }
}


int condition()
{
   if (token->ID == oddsym)
   {
      // somehow save the id of what you are rn
      // so you can produce the instuction later
      token = token->next;
      errHandle = expression();

      if (errHandle != 0)
      {
         return errHandle;
      }

      // generate instruction here
      gen(15, currRegPos, currRegPos, 0);
   }
   else 
   {
      errHandle = expression();

      if (errHandle != 0)
      {
         return errHandle;
      }

      switch (token->ID)
      {
         // somehow save the id of what you are rn 
         // so you can produce the instuction later
         case eqsym:
            token = token->next;
            errHandle = expression();

            if (errHandle != 0)
            {
               return errHandle;
            }

            // generate instruction here
            gen(17, currRegPos-1, currRegPos-1, currRegPos);
            currRegPos--;
            break;
         case neqsym:

            token = token->next;
            errHandle = expression();

            if (errHandle != 0)
            {
               return errHandle;
            }

            // generate instruction here
            gen(18, currRegPos-1, currRegPos-1, currRegPos);
            currRegPos--;
            break;
         case lessym:

            token = token->next;
            errHandle = expression();

            if (errHandle != 0)
            {
               return errHandle;
            }

            // generate instruction here
            gen(19, currRegPos-1, currRegPos-1, currRegPos);
            currRegPos--;
            break;
         case leqsym:

            token = token->next;
            errHandle = expression();

            if (errHandle != 0)
            {
               return errHandle;
            }

            // generate instruction here
            gen(20, currRegPos-1, currRegPos-1, currRegPos);
            currRegPos--;
            break;
         case gtrsym:

            token = token->next;
            errHandle = expression();

            if (errHandle != 0)
            {
               return errHandle;
            }

            // generate instruction here
            gen(21, currRegPos-1, currRegPos-1, currRegPos);
            currRegPos--;
            break;
         case geqsym:

            token = token->next;
            errHandle = expression();

            if (errHandle != 0)
            {
               return errHandle;
            }

            // generate instruction here
            gen(22, currRegPos-1, currRegPos-1, currRegPos);
            currRegPos--;
            break;
         default:

            // TODO: handle error relational operator expected
            return -1;
      }
   }
   return 0;
}

int expression()
{
   int addop;

   if (token->ID == plussym || token->ID == minussym)
   {
      addop = token->ID;
      token = token->next;

      errHandle = term();

      if (errHandle != 0)
      {
         return errHandle;
      }

      if (addop == minussym) 
      {
         gen(10, currRegPos, currRegPos, 0);
      }
   }
   else 
   {
      term();

      while (token->ID == plussym || token->ID == minussym)
      {
         addop = token->ID;
         token = token->next;

         errHandle = term();

         if (errHandle != 0)
         {
            return errHandle;
         }

         if (addop == plussym) 
         {
            gen(11, currRegPos-1,currRegPos-1,currRegPos);
            currRegPos--;
         }
         else 
         {
            gen(12, currRegPos-1,currRegPos-1, currRegPos);
            currRegPos--;
         }
      }
   }

   return 0;
}


int term()
{
   int mulop;
   errHandle = factor();

   if (errHandle != 0) 
   {
      return -1;
   } 

   while (token->ID == multsym || token->ID == slashsym) 
   {
      mulop = token->ID;
      token = token->next;
      errHandle = factor();

      if (errHandle != 0) 
      {
         return -1;
      }

      if (mulop == multsym) 
      {
         gen(13, currRegPos-1, currRegPos-1, currRegPos);
         currRegPos--;
      }
      else 
      {
         gen(14, currRegPos-1, currRegPos-1, currRegPos);
         currRegPos--;
      }
   }

   // End
   return 0;
}


int factor() 
{
   Symbol *currentSymbol = NULL;

   if (token->ID == identsym)
   {
      currentSymbol = lookUp(token->word);
      if (currentSymbol == NULL) 
      {
         // TODO: Handle Bad Lookup Error
         return -1;
      }

      gen(3, currRegPos, searchLexical, curInsertionOffset);
   }
   else if (token->ID == numbersym)
   {
      gen(1, currRegPos, searchLexical, atoi(token->word));
   }
   else if (token->ID == lparentsym)
   {
      // Get Next Token
      token = token->next;
      expression();

      if (token->ID != rparentsym)
      {
         // TODO: Handle Missing Paren Error
         return -1;
      }
      token = token->next;
   }
   return 0;
}



int addToTable(Symbol symbol)
{
   lastIndexOfST++;

   if (lastIndexOfST >= MAX_SL_LENGTH) 
   {
      //TODO: handle error to0 many symbols!!!!
      return -1;
   }

   symbolTable[lastIndexOfST] = toBeInserted;
   return 0;
}


// Be carefull with error handling in this one. 
// In case of error you return NULL instead of -1
Symbol *lookUp(char *symbol)
{
   int i;

   strcpy(symbolTable[0].name, symbol);

   for (i = lastIndexOfST -1; i >= 0; i--)
   {
      if (strcmp(symbol, symbolTable[i].name) == 0)
      {
         if (i == 0)
         {
            // TODO: error variable/constant not defined
            return NULL;
         }
         else if (symbolTable[i].mark == 1)
         {
            // TODO: error variable outside of scope
            return NULL;	
         }
         else
         {
            return &symbolTable[i];
         }
      }
   }
   // This should never occur, but if it does, RIP you.
   return NULL;
}

// Helper Func.
int gen(int OP, int REG, int L, int M) 
{
   // Build Instruction at current PC (according to Parser)
   if (currRegPos > MAX_REG) 
   {
      // TODO: Handle Error
      return -1;
   }

   IR[currPC].OP = OP;
   IR[currPC].REG = REG;
   IR[currPC].L = L;
   IR[currPC].M = M;

   if (OP == 1 || OP == 3) 
   {
      currRegPos++;
   }

   // Increment currPC to empty slot
   currPC++;
   return 0;
}

// Helpr Function: Prints the entirety of the Instruction Register
void printIR() 
{
   fprintf(stdout, "\nInstruction(s)\n--------------------\n");
   fprintf(output, "\nInstruction(s)\n--------------------\n");
   
   for (int i =0; i < currPC; i ++) 
   {
      fprintf(stdout, "%02d %02d %02d %02d\n", IR[i].OP, IR[i].REG, IR[i].L, IR[i].M);
      fprintf(output, "%02d %02d %02d %02d\n", IR[i].OP, IR[i].REG, IR[i].L, IR[i].M);
   }
   fprintf(stdout, "\n\n");
   fprintf(output, "\n\n");
}
